<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>两个链表的第一个公共节点</title>
      <link href="/2018/05/13/Coding-Interviews-52/"/>
      <url>/2018/05/13/Coding-Interviews-52/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>输入两个链表，找出它们的第一个公共结点。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>O(mn)的复杂度,遍历两次</li><li>利用单链表的隐藏特性,两个拥有公共节点的单链表形状是一个Y型,则从其相交之后则相同,则我们可以思考从最后往前进行比较,找到第一个不同的。则后进先出。用栈实现,或者先得到其长度，倒数相同的索引开始向前遍历,找到第一个相同的。但是求长度也需要额外的时间复杂度呀。</li><li>倒置单链表,再从头开始。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">单链表的数据类型</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>可不可以用递归来进行实现呢</p>]]></content>
      
      
        <tags>
            
            <tag> Coding Interviews </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>替换空格</title>
      <link href="/2018/05/13/Coding-Interviews-5/"/>
      <url>/2018/05/13/Coding-Interviews-5/</url>
      <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><a id="more"></a></p></blockquote><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ul><li>C++和java解决本问题有比较关键的区别(字符串存储方式不同)</li><li>StringBuffer.replace(int start, int end, String str)可以在做一些处理后直接替换</li><li><p>本题不适合java</p></li><li><p>具体思路</p><ol><li>先计算出目标字符串的长度</li><li>从字符串尾部向前组织新的字符串</li></ol></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="java自己的解决办法"><a href="#java自己的解决办法" class="headerlink" title="java自己的解决办法"></a>java自己的解决办法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer stringBuffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuffer.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stringBuffer.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">                stringBuffer.replace(i, i+<span class="number">1</span>, <span class="string">"%20"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuffer.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuffer源码"><a href="#StringBuffer源码" class="headerlink" title="StringBuffer源码"></a>StringBuffer源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.replace(start, end, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(start);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; count)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(<span class="string">"start &gt; length()"</span>);</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(<span class="string">"start &gt; end"</span>);</span><br><span class="line">    <span class="keyword">if</span> (end &gt; count)</span><br><span class="line">        end = count;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    <span class="keyword">int</span> newCount = count + len - (end - start);</span><br><span class="line">    ensureCapacityInternal(newCount);</span><br><span class="line">    System.arraycopy(value, end, value, start + len, count - end);</span><br><span class="line">    str.getChars(value, start);</span><br><span class="line">    count = newCount;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Coding Interviews </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组中重复的数字</title>
      <link href="/2018/05/13/Coding-Interviews-3/"/>
      <url>/2018/05/13/Coding-Interviews-3/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中<strong>任意一个</strong>重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。<br><a id="more"></a></p></blockquote><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ol><li><p>利用一个大小为n的hashmap存储每个数字的个数，当发现数字已经存在的时候，返回。</p></li><li><p>思路1我们发现有题目中的隐藏条件没有用到，即所有得数字都在0-的范围内，则我们可以不需要额外的数据结构就能够实现变量个数的统计。当 nums[nums[i]] == nums[i]时进行处理。</p></li><li>利用一个辅助数组对数据进行存储，避免思路2中数组内元素的交换。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SolutionClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 前面记得判断数据有效性 即数据的范围为0-n-1</span></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[nums[i]])&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                nums[i] = nums[tmp];</span><br><span class="line">                nums[tmp] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不存在重复的</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误总结"><a href="#错误总结" class="headerlink" title="错误总结"></a>错误总结</h2><p><strong> 数据有效性和最后不存在重复的情况 </strong></p>]]></content>
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> Coding Interviews </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CMake syntax</title>
      <link href="/2017/06/01/CMake-syntax/"/>
      <url>/2017/06/01/CMake-syntax/</url>
      <content type="html"><![CDATA[<p><img src="https://pic3.zhimg.com/80/f57298cefba18fca5f31b8762f01d933_hd.jpg" alt="make流程"></p>]]></content>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数字图像处理</title>
      <link href="/2017/05/31/Image-processing/"/>
      <url>/2017/05/31/Image-processing/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NachOS4.1 virtulal memary management</title>
      <link href="/2017/05/31/NachOS4-1-virtulal-memary-management/"/>
      <url>/2017/05/31/NachOS4-1-virtulal-memary-management/</url>
      <content type="html"><![CDATA[<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><ol><li>在Nachos中修改目前的内存分配方式，使得多个线程可以同时存在于内存之中，这些线程可以按照“优先级”的方式进行调度。</li></ol><a id="more"></a><h2 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h2><ul><li>虚拟内存</li><li>TLB</li></ul><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><h2 id="程序执行流程"><a href="#程序执行流程" class="headerlink" title="程序执行流程"></a>程序执行流程</h2><h3 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h3><h3 id="需要修改的文件列表"><a href="#需要修改的文件列表" class="headerlink" title="需要修改的文件列表"></a>需要修改的文件列表</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/liu-yiwei/NachOS" target="_blank" rel="noopener">最终代码实现(每提交一次对应一个实验)</a></p><p><a href="http://oqt3wq2vs.bkt.clouddn.com/blog/20170531/153417098.pdf" target="_blank" rel="noopener">Implementing Virtual Memory on Nachos</a></p><p><a href="http://www.wendangku.net/doc/9383d57a5acfa1c7aa00ccd6-11.html" target="_blank" rel="noopener">Nachos 实验11 设计并实现用户空间的虚拟内存管理-上</a></p><p><a href="http://m.wendangku.net/doc/f97f7e6a9b6648d7c1c746b8-13.html" target="_blank" rel="noopener">北大 nachos 考试 虚拟内存实验讲解</a></p><p><a href="http://blog.chinaunix.net/uid-20282925-id-3384481.html" target="_blank" rel="noopener">Nachos LAB3 内存管理试验 报告</a></p><p><a href="http://blog.sina.com.cn/s/blog_4ae8f77f01018n6r.html" target="_blank" rel="noopener">Nachos3.4 Lab3 虚拟内存管理 实习报告 分页式内存管理</a></p>]]></content>
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
